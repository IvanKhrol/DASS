# DASS

## Описание проекта

Реализация протокола DASS на С++ в рамках зачёта для курса "Криптографических протоколов"

### Состав

--

## Определение протокола

Протокол DASS (англ. Distributed Authentication Security Service) — асимметричный протокол аутентификации и распределения сеансовых ключей с использованием промежуточной доверенной стороны.

## Описание протокола

1. Алиса посылает сообщение Тренту на получение открытого ключа Боба
$$ Alice \xrightarrow{B} Trent $$

2. Трент присылает открытый ключ Боба, подписав его своим закрытым ключом
$$ Trent \xrightarrow{S_T(B, K_B)} Alice $$

3. Алиса проверяет данные с помощью известного ей заранее открытого ключа Трента, после чего генерирует сеансовый ключ $ K $, сеансовую пару ключей $ K_P $ и посылает набор сообщений Бобу, включая метку времени $ T_A $ и срок жизни ключа  $ L $ часть из них шифруя, часть подписывая:
$$ Alice \xrightarrow{E_K(T_A),\ S_A(L, A, K_P),\ S_{K_P}(E_{K_B}(K))}Bob $$

4. Боб отправляет Тренту запрос на получение открытого ключа Алисы
$$ Bob\xrightarrow{A}Trent $$

5. Трент присылает открытый ключ Алисы, подписав его своим закрытым ключом

$$ Trent\xrightarrow{S_T(A, K_A)}Bob $$

6. Используя данные из сообщений Алисы и Трента, Боб проверяет подписи Алисы, извлекает открытый временный ключ $ K_P $, извлекает сеансовый ключ $ K $ (проверяя также подпись с использованием $ K_P $), и расшифровывает $ T_A $ убеждаясь, что использует текущее сообщение, а не повтор.

7. **При необходимости протокол может быть продолжен, обеспечивая взаимную идентификацию сторон:
$$ Bob\xrightarrow{E_K(T_B)}→Alice $$ 

8. **Алиса расшифровывает метку времени и убеждается, что получила текущее сообщении

## Уязвимости и минусы

В протоколе используется время жизни ($L$) сеансового ключа $K_P$, однако в сообщение не включена метка времени. В результате протокол остаётся уязвимым к атаке с известным сеансовым ключом. Предположим, что Меллори смогла записать полностью прошедший сеанс связи между Алисой и Бобом, а потом смогла получить доступ к сеансовому ключу $K$. Это позволяет Меллори аутентифицировать себя как Алиса перед Бобом.

1. $$ Mellory(Alice) \xrightarrow{E_K(T_M),S_A(L, K_P), S_{K_P}(E_B(K))}  Bob $$
2. $$ Bob \xrightarrow{A} Trent $$
3. $$ Trent \xrightarrow{S_T(A,K_A)} Bob $$
4. $$ Bob \xrightarrow{E_K{T_B}} Alice $$

На первом проходе Меллори меняет только первое сообщение, содержащее метку времени $E_K \left( T_M \right)$. Всё остальное Меллори копирует из записанного сеанса связи. Если Боб не записывает используемые ключи, он не заметит подмены. Простейшее исправление данной уязвимости состоит во включении метки времени в сообщение $S_A \left( T_A, L, A, K_P \right)$.

Так как в протоколе сеансовый ключ $K$ шифруется «мастер»-ключом Боба $K_B$, то компрометация последнего приведёт к компрометации всех использованных ранее сеансовых ключей. То есть протокол не обеспечивает совершенной прямой секретности (цель G9).

Ни Трент, ни Боб не участвуют в формировании новых сеансовых ключей. Поэтому Алиса может заставить Боба использовать старый сеансовый ключ, как в протоколах Wide-Mouth Frog и Yahalom.
