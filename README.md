# DASS

## Описание проекта

Реализация протокола DASS на С++ в рамках зачёта для курса "Криптографических протоколов"

### Состав

--

## Определение протокола

Протокол DASS (англ. Distributed Authentication Security Service) — асимметричный протокол аутентификации и распределения сеансовых ключей с использованием промежуточной доверенной стороны.

## Описание протокола

1. Алиса посылает сообщение Тренту на получение открытого ключа Боба

$$ Alice \rightarrow[B]\rightarrow Trent $$

3. Трент присылает открытый ключ Боба, подписав его своим закрытым ключом

$$ Trent \rightarrow[S_T(B, K_B)]\rightarrow Alice $$

4. Алиса проверяет данные с помощью известного ей заранее открытого ключа Трента, после чего генерирует сеансовый ключ $K$, сеансовую пару ключей $K_P$ и посылает набор сообщений Бобу, включая метку времени $T_A$ и срок жизни ключа  $L$ часть из них шифруя, часть подписывая:

$$ Alice \rightarrow[E_K(T_A),\ S_A(L, A, K_P),\ S_{K_P}(E_{K_B}(K))]\rightarrow Bob $$

5. Боб отправляет Тренту запрос на получение открытого ключа Алисы
   
$$ Bob\rightarrow[A]\rightarrow Trent $$

7. Трент присылает открытый ключ Алисы, подписав его своим закрытым ключом

$$ Trent \rightarrow[S_T(A, K_A)]\rightarrow Bob $$

6. Используя данные из сообщений Алисы и Трента, Боб проверяет подписи Алисы, извлекает открытый временный ключ $K_P$, извлекает сеансовый ключ $K$ (проверяя также подпись с использованием $K_P$), и расшифровывает $T_A$ убеждаясь, что использует текущее сообщение, а не повтор.

7. **При необходимости протокол может быть продолжен, обеспечивая взаимную идентификацию сторон:
   
$$ Bob \rightarrow[E_K(T_B)]\rightarrow Alice $$ 

9. **Алиса расшифровывает метку времени и убеждается, что получила текущее сообщении

## Уязвимости и минусы

В протоколе используется время жизни ($L$) сеансового ключа $K_P$, однако в сообщение не включена метка времени. В результате протокол остаётся уязвимым к атаке с известным сеансовым ключом. Предположим, что Меллори смогла записать полностью прошедший сеанс связи между Алисой и Бобом, а потом смогла получить доступ к сеансовому ключу $K$. Это позволяет Меллори аутентифицировать себя как Алиса перед Бобом.

   $$ Mellory(Alice) \rightarrow[E_K(T_M),S_A(L, K_P), S_{K_P}(E_B(K))]\rightarrow Bob $$
   
   $$ Bob \rightarrow[A]\rightarrow Trent $$

   $$ Trent \rightarrow[S_T(A,K_A)]\rightarrow Bob $$

   $$ Bob \rightarrow[E_K{T_B}]\rightarrow Alice $$

На первом проходе Меллори меняет только первое сообщение, содержащее метку времени $E_K (T_M )$. Всё остальное Меллори копирует из записанного сеанса связи. Если Боб не записывает используемые ключи, он не заметит подмены. Простейшее исправление данной уязвимости состоит во включении метки времени в сообщение $S_A(T_A, L, A, K_P)$.

Так как в протоколе сеансовый ключ $K$ шифруется «мастер»-ключом Боба $K_B$, то компрометация последнего приведёт к компрометации всех использованных ранее сеансовых ключей. То есть протокол не обеспечивает совершенной прямой секретности (цель G9).

Ни Трент, ни Боб не участвуют в формировании новых сеансовых ключей. Поэтому Алиса может заставить Боба использовать старый сеансовый ключ, как в протоколах Wide-Mouth Frog и Yahalom.
